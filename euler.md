# Лабораторная работа №1

```
Выполнил: Шляпников Александр P3322

Вариант: 10, 21
```

## Проблема 10

### Описание

Сумма простых чисел меньше 10 равна 2 + 3 + 5 + 7 = 17.

Найдите сумму всех простых чисел меньше двух миллионов.

### Реализация

В рамках решения этой проблемы были разработаны две различные реализации

#### Реализация на основе ленивых последовательностей

``` ./src/problem_10/lazy_sequence_solve.clj ```

Создается последовательность от 2 до n при помощи iterate, из которой удаляются те числа,
что делятся хотя бы на какое-то уже найденное простое число

```clojure
 (def primes
   (remove
     (fn [x]
       (some #(zero? (mod x %)) primes))
     (iterate inc 2)))
 ```


#### Реализация на основе спец. синтаксиса для циклов

``` ./src/problem_10/loop_solve.clj ```

Clojure предлагает конструкцию loop, который работает на базе хвостовой рекурсии

Данная реализация построена на базе решета Эратосфена

Генерируем мапу "число" -> true \ false (Простое?)

```clojure
 (defn n-size-map [n]
   (loop [i 2 arr {}]
     (if (<= i n)
       (recur (+ 1 i) (into arr {i true}))
       arr)))
 ```

Для просеивания числа перебираем всю мапу и проставляем false

```clojure
 (defn remove-divides [n map]
   (loop [i (* n n) new-map map size (+ 1 (count map))]
     (if (<= i size)
       (recur (+ i n) (assoc new-map i false) size)
       new-map)))
 ```

и т.д. для каждого числа


## Проблема 21

### Описание

Пусть d(n) определяется как сумма делителей n (числа меньше n, делящие n нацело).
Если d(a) = b и d(b) = a, где a ≠ b, то a и b называются дружественной парой, а каждое из чисел a и b - дружественным числом.

Например, делителями числа 220 являются 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 и 110, поэтому d(220) = 284. Делители 284 - 1, 2, 4, 71, 142, поэтому d(284) = 220.

Подсчитайте сумму всех дружественных чисел меньше 10000.

### Реализация

В рамках решения этой проблемы были разработаны две различные реализации

#### Реализация на основе хвостовой рекурсии

Для поиска дружественных чисел требуется вычислить для каждого числа его делители:

```clojure
(defn dividers
  ([n] (dividers n 2 0))
  ([n cur dividers]
   (if (> cur (Math/ceil (/ n 2)))
     (+ dividers 1)
     (recur n (+ cur 1) (+ dividers (* (if (zero? (mod n cur)) 1 0) cur))))))
```

После этого проходимся по всем числам и ищем согласно условию:

```clojure
(defn solve
  ([n] (solve n 1 {}))

  ; Формируем мапу число -> делитель
  ([n cur nums]
   (if (>= cur n)
     (solve n 1 nums 0)
     (recur n (+ cur 1) (into nums {cur (dividers cur)}))))

  ; Проходимся по мапе и проверяем условие дружественности
  ([n cur nums friendlies]
   (if (>= cur n)
     friendlies
     (let [dividers (get nums cur)
           on-check (get nums dividers)]
       (recur n (+ cur 1) nums (+ (* (if (and (= cur on-check) (not= dividers cur)) 1 0) cur) friendlies))))))
```


#### Модульная реализация

Логика работы алгоритма осталась такая же изменился только подход

Ищем делители:

1. Формируем последовательность - iterate
2. Фильтруем - filter
3. Сворачиваем - reduce

```clojure
(defn dividers [n]
  (reduce + (filter #(zero? (mod n %)) (take (Math/ceil (/ n 2)) (iterate inc 1)))))
```

Проходимся по последовательность и ищем подходящие

1. Формируем последовательность (with-dividers) - map
2. Сворачиваем в общую мапу чисел - reduce
3. Фильтруем по условию - filter
4. Отображаем мапу в лист - map
5. Сворачиваем лист в число - reduce

```clojure
(defn solve [n]
  (let [with-dividers (reduce into (map (fn [x] {x (dividers x)}) (take n (iterate inc 2))))]
    (reduce + (map first (filter (fn [entry]
                                   (let [num (first entry)
                                         dividers (second entry)
                                         on-check (get with-dividers dividers)]
                                     (and (= num on-check) (not= dividers num)))) with-dividers)))))
```

## Вывод

В общем и целом полезная лабораторная позволила на простых примерах пощупать язык и разобраться в базовых концепциях.

Было интересно попробовать различные подходы при написании алгоритмов.
Использование каждого из них позволило по разному взглянуть на проблему и в большинстве своем это было интересно,
за исключение разве что встроенной конструкции loop, видимо призванной чисто семантически упростить работу с циклами
в виду их отсуствия, однако на мой взгляд код использующий его выглядит довольно громоздко.
Наиболее лаконичным и удобочитаемым думаю могу назвать модульную реализацию и реализацию на базе ленивых коллекций.
На мой взгляд именно эти варианты реализации способны проиллюстрировать красоту функционального подхода к решению задачи.